<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Orient markers toward the horizon</title>
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
    <link href="https://api.mapbox.com/mapbox-gl-js/v3.0.0/mapbox-gl.css" rel="stylesheet">
    <script src="https://api.mapbox.com/mapbox-gl-js/v3.0.0/mapbox-gl.js"></script>
    
    <script src="https://d3js.org/d3.v6.min.js"></script>

    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: black;
        }
        #map {
            width: 550px;  /* or your desired size */
            height: 550px; /* make width and height equal for a perfect circle */
            border-radius: 50%; /* this creates the circular shape */
            overflow: hidden; /* this ensures anything outside the circle is not shown */
            margin: auto;
        }

        /*Use Svg Image to Highlight the Location*/
        /* .custom-marker {
            background-image: url('./src/icon.svg'); 
            background-size: cover;
            width: 25px;  
            height: 25px; 
            opacity: 0.5;
        } */

        /*Use the blur circle directly*/
        .custom-marker {
            background-color: rgb(170, 32, 32);
            border-color: rgb(0, 0, 0);
            border-width: 1px;
            border-style: double;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            /* box-shadow: 0 0 6px 2px rgb(161, 36, 36); */
        }

        #scatter-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 900px; /* Larger than the map to fit around it */
            height: 900px;
            pointer-events: none; /* Allows interaction with the map underneath */
        }

        #refreshData {
            position: fixed; /* Fixed location */
            top: 400px; /* Top location */
            right: 100px; /* Right location */
            padding: 10px; /* Offset dist */
            background-color: #4b4b4b; /* background color */
            color: white; /* font color */
            border-color: white;
            border-radius: 5px; /* fillet radius */
            cursor: pointer; /* hand shape pointer */
            font-size: 15px;
            font-weight: 900;
            font-family:Georgia, 'Times New Roman', Times, serif;
        }

        #refreshData:hover {
            background-color: #383838; /* Hover color */
        }

    </style>
</head>
<body>
    <div id="map"></div>

    <div id="scatter-container"></div>

    <button id="refreshData">RefreshData</button>
    

    <script src="./js/mapbox.js"></script>

    <script>
        
        mapboxgl.accessToken = mapboxToken;

        const map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/tianmingliu/clpu8cl6m01e501p98ycf61ej',
            center: [130, 35],
            zoom:  1.71,
            minZoom: 1.71,
            logoPosition: 'top-right',
            attributionControl: false,
        });

        // Function to fetch earthquake data
        async function fetchEarthquakeData() {
            const today = new Date();
            const tomorrow = new Date();
            tomorrow.setDate(today.getDate() + 1);

            const formatDate = (date) => date.toISOString().split('T')[0];

            const url = `https://earthquake.usgs.gov/fdsnws/event/1/query?format=geojson&starttime=${formatDate(today)}&endtime=${formatDate(tomorrow)}&minmagnitude=1`;

            // const url = `https://earthquake.usgs.gov/fdsnws/event/1/query?format=geojson&starttime=2023-12-05&endtime=2023-12-06&minmagnitude=1`;

            try {
                const response = await fetch(url);
                const data = await response.json();
                return data.features; // Return the array of earthquake features
            } catch (error) {
                console.error('Error fetching earthquake data:', error);
                return [];
            }
        }

        // Function to add earthquake markers to the map
        function addEarthquakeMarkersToMap(map, earthquakes) {
            earthquakes.forEach(quake => {
                const { coordinates } = quake.geometry;
                const { mag, place } = quake.properties;

                const el = document.createElement('div');
                el.className = 'custom-marker';

                new mapboxgl.Marker(el)
                    .setLngLat([coordinates[0], coordinates[1]]) // Longitude, Latitude
                    .setPopup(new mapboxgl.Popup({ offset: 25 })
                    .setHTML(`<strong>Magnitude:</strong> ${mag}<br/><strong>Location:</strong> ${place || 'Unknown'}`))
                    .addTo(map);
            });
        }

        // Function to get the realtime location of the user
        function getUserLocation() {
            return new Promise((resolve, reject) => {
                if (!navigator.geolocation) {
                    reject('Geolocation is not supported by your browser');
                } else {
                    navigator.geolocation.getCurrentPosition(resolve, reject);
                }
            });
        }

        // Map Usage
        map.on('load', async () => {        
            const earthquakes = await fetchEarthquakeData();
            addEarthquakeMarkersToMap(map, earthquakes);
            // Circle Scatter Chart
            const earthquakeDatas = preprocessData(earthquakes);
            createCircularScatterChart(earthquakeDatas);

            // Rotate View to current location
            try {
                const userLocation = await getUserLocation();
                const userLat = userLocation.coords.latitude;
                const userLng = userLocation.coords.longitude;

                const currentBearing = map.getBearing();

                map.flyTo({
                    center: [userLng, userLat],
                    bearing: currentBearing,
                    zoom: map.getZoom(), // keeps the current zoom level
                    essential: true, // this animation is considered essential with respect to prefers-reduced-motion
                    speed: 0.3, // adjust this value as needed, lower is slower
                    duration: 8000 // duration of the transition in milliseconds, adjust as needed
                });
            } catch(error) {
                console.error('Error getting user location:', error);
            }
            });

        function preprocessData(features) {
            return features.map(feature => {
                return {
                    time: new Date(feature.properties.time), // Convert timestamp to Date object
                    magnitude: feature.properties.mag,
                    title: feature.properties.title
                };
            });
        }


        function createCircularScatterChart(data) {
            const width = 900, height = 900, radius = 290;
            const svg = d3.select("#scatter-container").append("svg")
                .attr("width", width)
                .attr("height", height);

            const g = svg.append("g")
                .attr("transform", `translate(${width / 2}, ${height / 2})`);

            
            const axisLineLength = 0; // length for time line
            const numRadials = 24; // Num of the time line
            for (let i = 0; i < numRadials; i++) {
                const angle = (i / numRadials) * 2 * Math.PI;
                // Calculate the time line startPt and endPt
                const lineStartX = (radius - 4) * Math.cos(angle);
                const lineStartY = (radius - 4) * Math.sin(angle);
                const lineEndX = (radius - axisLineLength) * Math.cos(angle);
                const lineEndY = (radius - axisLineLength) * Math.sin(angle); 

                g.append("line")
                .attr("x1", lineStartX)
                .attr("y1", lineStartY)
                .attr("x2", lineEndX)
                .attr("y2", lineEndY)
                .style("stroke", "white")
                .style("stroke-width", 1);

                // Add time anotation
                if (i % 1 === 0) { // Every two hours
                    // Set a offset distance for time anotation
                    const offset = 10;
                    const textX = lineEndX - offset * Math.cos(angle);
                    const textY = lineEndY - offset * Math.sin(angle);

                    // Calculate the angle to rotate the text for making it parallel with the circle
                    const textRotation = angle * (180 / Math.PI) - 90;

                    // Create the text element for time anotation
                    const textGroup = g.append("g")
                        .attr("transform", `translate(${textX},${textY}) rotate(${textRotation})`);

                    // Add time series anotation
                    textGroup.append("text")
                        .attr("dy", ".35em")
                        .style("text-anchor", "middle")
                        .style("font-size", "10px")
                        .style("fill", "white")
                        .text(`${i * 2}:00`);
                }
            }
            const extendLineLength =10;
            const textOffset = 10;
            

            // Create a scale to map the magnitude
            const radiusScale = d3.scaleLinear()
                .domain([0, d3.max(data, d => d.magnitude || 0)])
                .range([1, 9]); // Set the radius range for the point to change


            data.forEach(d => {
                // Use UTC time to get the hour and minute
                const hours = d.time.getUTCHours();
                const minutes = d.time.getUTCMinutes();
                const totalMinutes = hours * 60 + minutes;

                // Convert the time among the day into the degree of the circle scatter chart
                const angle = (totalMinutes / (24 * 60)) * 2 * Math.PI;

                // Calculate the location of the scatter point
                const x = radius * Math.cos(angle);
                const y = radius * Math.sin(angle);

                 // Calculate the circle radius via scale
                const pointRadius = radiusScale(d.magnitude || 0); // If there is no mag data, display 0

                // Add scatter points in the chart
                g.append('circle')
                    .attr('cx', x)
                    .attr('cy', y)
                    .attr('r', pointRadius) // Dot radius
                    .style('fill', 'white'); // Dot color
                
                // Add line for the anotation
                const lineEndX = (radius + extendLineLength) * Math.cos(angle);
                const lineEndY = (radius + extendLineLength) * Math.sin(angle);

                g.append("line")
                    .attr("x1", x)
                    .attr("y1", y)
                    .attr("x2", lineEndX)
                    .attr("y2", lineEndY)
                    .style("stroke", "grey")
                    .style("stroke-width", 0.5)
                    .style("stroke-dasharray", "2,2");
                // Add earthquake detail
                if (d.title) {
                    // split the text to display the location only
                    const titleParts = d.title.split('of');

                    // get the location info behind the "of"
                    const displayedLocation = titleParts[1] ? titleParts[1].trim() : "No location details";

                    const displayColor = titleParts[1] ? "white" : "red";

                    const displaySize = titleParts[1] ? "9px" : "7px";

                    const textAngle = angle * (180 / Math.PI); // Convert the degree

                    // Calculate the start location of text
                    const textStartX = x + (textOffset * Math.cos(angle));
                    const textStartY = y + (textOffset * Math.sin(angle));

                    // Calculate the text end location
                    const textAnchorX = lineEndX + (extendLineLength / 2) * Math.cos(angle);
                    const textAnchorY = lineEndY + (extendLineLength / 2) * Math.sin(angle);

                    g.append("text")
                        .attr("x", textStartX)
                        .attr("y", textStartY)
                        .style("text-anchor", "left")
                        .style("font-size", displaySize)
                        .style("fill", displayColor)
                        .attr("transform", `rotate(${textAngle},${textAnchorX},${textAnchorY})`)
                        .text(displayedLocation);
                };
            });
        }

        document.getElementById('refreshData').addEventListener('click', async () => {
            const earthquakes = await fetchEarthquakeData();
            addEarthquakeMarkersToMap(map, earthquakes);
            // Update the scatter chart
            const earthquakeDatas = preprocessData(earthquakes);
            createCircularScatterChart(earthquakeDatas);
        });

    </script>
</body>

</html>