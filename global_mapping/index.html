<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Orient markers toward the horizon</title>
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
    <link href="https://api.mapbox.com/mapbox-gl-js/v3.0.0/mapbox-gl.css" rel="stylesheet">
    <script src="https://api.mapbox.com/mapbox-gl-js/v3.0.0/mapbox-gl.js"></script>
    
    <script src="https://d3js.org/d3.v6.min.js"></script>

    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: black;
        }
        #map {
            width: 550px;  /* or your desired size */
            height: 550px; /* make width and height equal for a perfect circle */
            border-radius: 50%; /* this creates the circular shape */
            overflow: hidden; /* this ensures anything outside the circle is not shown */
            margin: auto;
        }

        /*Use Svg Image to Highlight the Location*/
        /* .custom-marker {
            background-image: url('./src/icon.svg'); 
            background-size: cover;
            width: 25px;  
            height: 25px; 
            opacity: 0.5;
        } */

        /*Use the blur circle directly*/
        .custom-marker {
            background-color: rgb(170, 32, 32);
            border-color: rgb(0, 0, 0);
            border-width: 1px;
            border-style: double;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            /* box-shadow: 0 0 6px 2px rgb(161, 36, 36); */
        }

        #scatter-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 900px; /* Larger than the map to fit around it */
            height: 900px;
            pointer-events: none; /* Allows interaction with the map underneath */
        }

        #refreshData {
            position: fixed; /* 固定位置 */
            top: 400px; /* 距离顶部20像素 */
            right: 100px; /* 距离右侧20像素 */
            padding: 10px; /* 内边距 */
            background-color: #4b4b4b; /* 背景色 */
            color: white; /* 字体颜色 */
            border-color: white;
            border-radius: 5px; /* 圆角 */
            cursor: pointer; /* 鼠标指针变为手形 */
            font-size: 15px;
            font-weight: 900;
            font-family:Georgia, 'Times New Roman', Times, serif;
        }

        #refreshData:hover {
            background-color: #383838; /* 鼠标悬停时的背景色 */
        }

    </style>
</head>
<body>
    <div id="map"></div>

    <div id="scatter-container"></div>

    <button id="refreshData">RefreshData</button>
    

    <script src="./js/mapbox.js"></script>

    <script>
        
        mapboxgl.accessToken = mapboxToken;

        const map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/tianmingliu/clpu8cl6m01e501p98ycf61ej',
            center: [130, 35],
            zoom:  1.71,
            minZoom: 1.71,
            logoPosition: 'top-right',
            attributionControl: false,
        });

        // Function to fetch earthquake data
        async function fetchEarthquakeData() {
            const today = new Date();
            const tomorrow = new Date();
            tomorrow.setDate(today.getDate() + 1);

            const formatDate = (date) => date.toISOString().split('T')[0];

            const url = `https://earthquake.usgs.gov/fdsnws/event/1/query?format=geojson&starttime=${formatDate(today)}&endtime=${formatDate(tomorrow)}&minmagnitude=1`;

            // const url = `https://earthquake.usgs.gov/fdsnws/event/1/query?format=geojson&starttime=2023-12-05&endtime=2023-12-06&minmagnitude=1`;

            try {
                const response = await fetch(url);
                const data = await response.json();
                return data.features; // Return the array of earthquake features
            } catch (error) {
                console.error('Error fetching earthquake data:', error);
                return [];
            }
        }

        // Function to add earthquake markers to the map
        function addEarthquakeMarkersToMap(map, earthquakes) {
            earthquakes.forEach(quake => {
                const { coordinates } = quake.geometry;
                const { mag, place } = quake.properties;

                const el = document.createElement('div');
                el.className = 'custom-marker';

                new mapboxgl.Marker(el)
                    .setLngLat([coordinates[0], coordinates[1]]) // Longitude, Latitude
                    .setPopup(new mapboxgl.Popup({ offset: 25 })
                    .setHTML(`<strong>Magnitude:</strong> ${mag}<br/><strong>Location:</strong> ${place || 'Unknown'}`))
                    .addTo(map);
            });
        }

        // Usage
        map.on('load', async () => {
            const earthquakes = await fetchEarthquakeData();
            addEarthquakeMarkersToMap(map, earthquakes);
            // Circle Scatter Chart
            const earthquakeDatas = preprocessData(earthquakes);
            createCircularScatterChart(earthquakeDatas);
        });

        function preprocessData(features) {
            return features.map(feature => {
                return {
                    time: new Date(feature.properties.time), // Convert timestamp to Date object
                    magnitude: feature.properties.mag,
                    title: feature.properties.title
                };
            });
        }


        function createCircularScatterChart(data) {
            const width = 900, height = 900, radius = 290;
            const svg = d3.select("#scatter-container").append("svg")
                .attr("width", width)
                .attr("height", height);

            const g = svg.append("g")
                .attr("transform", `translate(${width / 2}, ${height / 2})`);

            
            const axisLineLength = 0; // 引线长度
            const numRadials = 12; // 每两个小时一个时间标注
            for (let i = 0; i < numRadials; i++) {
                const angle = (i / numRadials) * 2 * Math.PI;
                // 计算时间刻度线的起点和终点坐标
                const lineStartX = (radius - 4) * Math.cos(angle);
                const lineStartY = (radius - 4) * Math.sin(angle);
                const lineEndX = (radius - axisLineLength) * Math.cos(angle); // 假设刻度线长度为5
                const lineEndY = (radius - axisLineLength) * Math.sin(angle); // 假设刻度线长度为5

                g.append("line")
                .attr("x1", lineStartX)
                .attr("y1", lineStartY)
                .attr("x2", lineEndX)
                .attr("y2", lineEndY)
                .style("stroke", "white")
                .style("stroke-width", 1);

                // 添加时间标注
                if (i % 1 === 0) { // 每两个小时
                    // 计算文本的位置并向圆心方向偏移（固定偏移方向）
                    const offset = 10; // 偏移量
                    const textX = lineEndX - offset * Math.cos(angle);
                    const textY = lineEndY - offset * Math.sin(angle);

                    // 计算文本的旋转角度，使其与切线方向相切
                    const textRotation = angle * (180 / Math.PI) - 90;

                    // 创建包含旋转的 <g> 元素，以使文字与切线方向相切
                    const textGroup = g.append("g")
                        .attr("transform", `translate(${textX},${textY}) rotate(${textRotation})`);

                    // 添加时间标注文本
                    textGroup.append("text")
                        .attr("dy", ".35em")
                        .style("text-anchor", "middle")
                        .style("font-size", "10px")
                        .style("fill", "white")
                        .text(`${i * 2}:00`);
                }
            }
            const extendLineLength =10;
            const textOffset = 10; // 文本距离数据点的偏移量
            

            // 创建一个比例尺，将震级映射到半径范围
            const radiusScale = d3.scaleLinear()
                .domain([0, d3.max(data, d => d.magnitude || 0)]) // 使用默认值0来处理没有震级信息的数据点
                .range([2, 7]); // 定义半径范围，根据需要调整


            data.forEach(d => {
                // 使用UTC时间来获取小时和分钟
                const hours = d.time.getUTCHours();
                const minutes = d.time.getUTCMinutes();
                const totalMinutes = hours * 60 + minutes;

                // 将总分钟数转换为圆上的角度
                const angle = (totalMinutes / (24 * 60)) * 2 * Math.PI;

                // 计算散点图的x和y坐标
                const x = radius * Math.cos(angle);
                const y = radius * Math.sin(angle);

                 // 计算圆点的半径，使用比例尺
                const pointRadius = radiusScale(d.magnitude || 0); // 使用默认值0来处理没有震级信息的数据点

                // 将圆点添加到SVG中
                g.append('circle')
                    .attr('cx', x)
                    .attr('cy', y)
                    .attr('r', pointRadius) // 圆点的半径
                    .style('fill', 'white'); // 圆点的颜色
                
                // 添加引线
                const lineEndX = (radius + extendLineLength) * Math.cos(angle);
                const lineEndY = (radius + extendLineLength) * Math.sin(angle);

                g.append("line")
                    .attr("x1", x)
                    .attr("y1", y)
                    .attr("x2", lineEndX)
                    .attr("y2", lineEndY)
                    .style("stroke", "grey")
                    .style("stroke-width", 0.5)
                    .style("stroke-dasharray", "2,2");
                // 添加标题标注
                if (d.title) {
                    // 使用 "of" 分割标题以获取 "of" 后面的内容
                    const titleParts = d.title.split('of');

                    // 获取 "of" 后面的内容，去除前后空格
                    const displayedLocation = titleParts[1] ? titleParts[1].trim() : "No location details";

                    const textAngle = angle * (180 / Math.PI); // 将弧度转换为度

                    // 计算文本的起始坐标，向外偏移一定距离
                    const textStartX = x + (textOffset * Math.cos(angle));
                    const textStartY = y + (textOffset * Math.sin(angle));

                    // 计算文本的锚点坐标
                    const textAnchorX = lineEndX + (extendLineLength / 2) * Math.cos(angle);
                    const textAnchorY = lineEndY + (extendLineLength / 2) * Math.sin(angle);

                    g.append("text")
                        .attr("x", textStartX)
                        .attr("y", textStartY)
                        .style("text-anchor", "left")
                        .style("font-size", "9.5px")
                        .style("fill", d.title ? "white" : "red")
                        .attr("transform", `rotate(${textAngle},${textAnchorX},${textAnchorY})`)
                        .text(displayedLocation);
                } else {
                    // 如果没有标题数据，则显示 "No location details" 文本标注
                    const textAngle = angle * (180 / Math.PI); // 将弧度转换为度

                    // 计算文本的起始坐标，向外偏移一定距离
                    const textStartX = x + (textOffset * Math.cos(angle));
                    const textStartY = y + (textOffset * Math.sin(angle)) + 12; // 向下偏移以避免覆盖

                    // 计算文本的锚点坐标
                    const textAnchorX = lineEndX + (extendLineLength / 2) * Math.cos(angle);
                    const textAnchorY = lineEndY + (extendLineLength / 2) * Math.sin(angle);

                    g.append("text")
                        .attr("x", textStartX)
                        .attr("y", textStartY)
                        .style("text-anchor", "left")
                        .style("font-size", "9.5px")
                        .style("fill", "red")
                        .attr("transform", `rotate(${textAngle},${textAnchorX},${textAnchorY})`)
                        .text("No location details");
                }
            });
        }

        document.getElementById('refreshData').addEventListener('click', async () => {
            const earthquakes = await fetchEarthquakeData();
            addEarthquakeMarkersToMap(map, earthquakes);
            // 这里可以添加其他更新地图的逻辑
            const earthquakeDatas = preprocessData(earthquakes);
            createCircularScatterChart(earthquakeDatas);
        });

    </script>
</body>

</html>